import jsPDF from 'jspdf';
import { DiscoveryFormData, SECTIONS } from '@/types/discovery';

interface PDFGenerationConfig {
  openaiApiKey?: string;
}

// Constants for content formatting
const MIN_HEADER_LENGTH = 5;
const MAX_HEADER_LENGTH = 60;

/**
 * Service for generating PDFs with LLM-enhanced formatting
 * Includes DEPT watermark on all pages
 */
export class PDFGenerationService {
  private config: PDFGenerationConfig;

  constructor(config: PDFGenerationConfig = {}) {
    this.config = config;
  }

  /**
   * Use an LLM to enhance and format the discovery data
   * In production, this would call OpenAI or another LLM API
   */
  private async enhanceContentWithLLM(data: DiscoveryFormData): Promise<string> {
    // In production, this would:
    // 1. Send the discovery data to an LLM (OpenAI, Claude, etc.)
    // 2. Ask the LLM to format it as a professional report
    // 3. Return the enhanced content
    
    // For now, we'll create a well-formatted structure manually
    let enhanced = 'ADOBE EXPERIENCE CLOUD DISCOVERY REPORT\n\n';
    enhanced += 'Executive Summary\n\n';
    enhanced += `This discovery report was prepared for ${data.generalInfo.companyName || 'the client'}. `;
    enhanced += 'The following sections detail the current state of their Adobe Experience Cloud implementation, ';
    enhanced += 'challenges, and opportunities for optimization.\n\n';

    SECTIONS.forEach((section) => {
      const sectionData = data[section.id as keyof DiscoveryFormData];
      enhanced += `\n${section.label}\n`;
      enhanced += '-'.repeat(section.label.length) + '\n\n';

      if (sectionData && typeof sectionData === 'object') {
        Object.entries(sectionData).forEach(([key, value]) => {
          const formattedKey = key
            .replace(/([A-Z])/g, ' $1')
            .trim()
            .replace(/^./, (str) => str.toUpperCase());

          let formattedValue = 'Not specified';
          if (Array.isArray(value)) {
            formattedValue = value.length > 0 ? value.join(', ') : 'Not specified';
          } else if (typeof value === 'object' && value !== null) {
            const entries = Object.entries(value as Record<string, string>).filter(
              ([, v]) => v
            );
            formattedValue =
              entries.length > 0
                ? entries.map(([k, v]) => `${k}: ${v}`).join('; ')
                : 'Not specified';
          } else if (value) {
            formattedValue = String(value);
          }

          enhanced += `${formattedKey}: ${formattedValue}\n`;
        });
      }

      enhanced += '\n';
    });

    return enhanced;
  }

  /**
   * Add DEPT watermark to the PDF
   */
  private addWatermark(doc: jsPDF, pageNumber: number, totalPages: number) {
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    // Add watermark text in background
    doc.setTextColor(240, 240, 240);
    doc.setFontSize(60);
    doc.setFont('helvetica', 'bold');
    
    // Save the current graphics state
    doc.saveGraphicsState();
    
    // Rotate and add watermark
    const centerX = pageWidth / 2;
    const centerY = pageHeight / 2;
    doc.text('DEPT®', centerX, centerY, {
      angle: 45,
      align: 'center',
    });
    
    doc.restoreGraphicsState();

    // Add footer with page numbers
    doc.setTextColor(100, 100, 100);
    doc.setFontSize(8);
    doc.text(
      `Page ${pageNumber} of ${totalPages} | Generated by DEPT®`,
      pageWidth / 2,
      pageHeight - 10,
      { align: 'center' }
    );

    // Add DEPT logo/branding in footer
    doc.setTextColor(255, 73, 1); // DEPT orange color
    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text('DEPT®', 14, pageHeight - 10);
  }

  /**
   * Generate a PDF from discovery data
   * @param data Discovery form data to include in the PDF
   * @param documentContent Optional pre-formatted content (reserved for future use with Google Docs integration)
   */
  async generatePDF(
    data: DiscoveryFormData,
    documentContent?: string
  ): Promise<{
    success: boolean;
    blob?: Blob;
    error?: string;
  }> {
    try {
      // Enhance content with LLM
      const enhancedContent = await this.enhanceContentWithLLM(data);

      // Create PDF
      const doc = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a4',
      });

      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const margin = 20;
      const lineHeight = 7;
      const maxWidth = pageWidth - 2 * margin;

      // Split content into lines
      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      const lines = doc.splitTextToSize(enhancedContent, maxWidth);

      let y = margin + 10;
      let pageNumber = 1;

      // Add watermark to first page
      this.addWatermark(doc, pageNumber, 1); // We'll update total pages later

      // Add header
      doc.setFontSize(18);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(255, 73, 1); // DEPT orange
      doc.text('Adobe Experience Cloud', margin, margin);
      doc.setFontSize(14);
      doc.text('Discovery Report', margin, margin + 8);

      doc.setTextColor(0, 0, 0);
      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      y = margin + 20;

      // Add content
      for (let i = 0; i < lines.length; i++) {
        if (y > pageHeight - 20) {
          doc.addPage();
          pageNumber++;
          this.addWatermark(doc, pageNumber, 1); // We'll update total pages later
          y = margin;
        }

        const line = lines[i];
        
        // Check if line is a header (all caps or ends with ':')
        if (line === line.toUpperCase() && line.length > MIN_HEADER_LENGTH && line.length < MAX_HEADER_LENGTH) {
          doc.setFont('helvetica', 'bold');
          doc.setFontSize(12);
          doc.setTextColor(255, 73, 1);
          y += 4;
        } else if (line.includes(':') && line.indexOf(':') < line.length / 2) {
          doc.setFont('helvetica', 'bold');
          doc.setFontSize(10);
          doc.setTextColor(0, 0, 0);
        } else {
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10);
          doc.setTextColor(60, 60, 60);
        }

        doc.text(line, margin, y);
        y += lineHeight;
      }

      // Update watermarks with correct total page count
      const totalPages = doc.getNumberOfPages();
      for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        // Re-add watermark with correct page numbers
        const pageHeight = doc.internal.pageSize.getHeight();
        const pageWidth = doc.internal.pageSize.getWidth();
        
        // Clear footer area
        doc.setFillColor(255, 255, 255);
        doc.rect(0, pageHeight - 15, pageWidth, 15, 'F');
        
        // Re-add watermark
        this.addWatermark(doc, i, totalPages);
      }

      // Generate blob
      const blob = doc.output('blob');

      return {
        success: true,
        blob,
      };
    } catch (error) {
      console.error('Error generating PDF:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Download the generated PDF
   */
  downloadPDF(blob: Blob, filename: string) {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
}

// Export a singleton instance
export const pdfGenerationService = new PDFGenerationService({
  openaiApiKey: import.meta.env.VITE_OPENAI_API_KEY,
});
